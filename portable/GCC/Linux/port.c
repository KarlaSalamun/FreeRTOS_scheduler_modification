/*
 * FreeRTOS Port implementation for Linux using POSIX Threads
 *
 * - Each RTOS tasks runs in a own thread
 * - Threads are suspended / resumed by async signals
 * - Those signal are generated by the scheduler thread
 * - vPortYield triggers the scheduler thread
 * - The systick is generated by a POSIX timer
 * - and is handled synchronized within the main thread
 * - While systick is handled all threads running RTOS tasks are suspended
 *
 * Debugging:
 * - Content of pxTasks might be a good staring point. It holds the state of the
 *   RTOS tasks and the corresponding thread id.
 *
 *
 * Copyright (C) 2019 Andreas Innerlohninger <innerand@nxa.at>
 *
 * This code is subject to the terms and conditions defined at the MIT Licence
 * which are specified at the end of this file and/or a separate license file.
 */


/* Includes ------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <semaphore.h>

#include "FreeRTOS.h"
#include "task.h"


/* Private Definitions -------------------------------------------------------*/

#define ERREXIT(s)  printf("Error: %s (%s[%d], %s)", (s), __FUNCTION__, __LINE__, __FILE__); exit(1)
// #define LOG(msg,...) printf("[%ld]", prvGetNsTs()); printf(msg, ##__VA_ARGS__); printf("\n");
#define LOG(msg,...)


/** Internal task credentials */
typedef struct {
    bool xUsed;               /* Task created */
    sig_atomic_t xSuspended;  /* Task suspended */
    int xId;                  /* Internal task ID */
    pthread_t xThreadId;      /* ID of the POSIX thread running the task */
    TaskHandle_t pxHandle;    /* RTOS task handle */
    TaskFunction_t pxCode;    /* RTOS task function */
    void * pvParameters;      /* RTOS function parameters */
} portTask_t;


/* Private Function declarations ---------------------------------------------*/

static void prvInit(void);
static void prvStartSchedulerThread(void);
static bool prvStartSystickTimer(void);
static void prvStopSystickTimer(void);
static void * prvSchedulerThread(void *arg);
static void * prvTask(void * arg);
static unsigned long prvGetNsTs(void);
static int prvGetIdFromHandle(TaskHandle_t handle);
static int prvGetIdFromThreadId(pthread_t id);
static void prvSchedulerEndCleanup( void );
static void prvSuspendTaskBlocking(int task_id);
static void prvResumeTaskBlocking(int task_id);
static void prvResumeSchedulerBlocking(void);

static void prvSigResumeHandler(int sig, siginfo_t *si, void *uc);
static void prvSigSuspendHandler(int sig, siginfo_t *si, void *uc);
static void prvSigtimerHandler(int sig, siginfo_t *si, void *uc);


/* Private Variables ---------------------------------------------------------*/

static volatile portTask_t pxTasks[configPORT_MAX_TASKS];
static int xLastCreatedTaskId = configPORT_MAX_TASKS;

/* Context switch IDs */
static volatile int xTaskToResume = configPORT_MAX_TASKS;
static volatile int xTaskToSuspend = configPORT_MAX_TASKS;

/* System Threads */
static pthread_t xMainThreadId;
static pthread_t xSchedulerThreadId;
static int xIdleTaskId;

/* Semaphores */
static sem_t xSchedulerSem;     /* Scheduler available  */
static sem_t xResumeSem;        /* (Any) Task has resumed */
static sem_t xSuspendSem;       /* (Any) Task is suspended */
static sem_t xCriticalSem;      /* Critical section */

/* Mutexes */
static pthread_mutex_t xSchedulerMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t xSchedulerCond = PTHREAD_COND_INITIALIZER;
static pthread_mutex_t xSchedulerStartedMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t xSchedulerStartedCond = PTHREAD_COND_INITIALIZER;

/* Flags */
static bool xEndScheduler = false;
static volatile sig_atomic_t xSystick = 0;
static volatile sig_atomic_t xTimerTickPending = 0;
static volatile bool xYieldPending = false;
static volatile bool xResumeScheduler = false;
static volatile bool xSchedulerStarted = false;
static volatile bool xPaused = false;
static bool xInitialized = false;

/* A variable is used to keep track of the critical section nesting.  This
variable has to be stored as part of the task context and must be xInitialized
to a non zero value to ensure interrupts don't inadvertently become unmasked
before the scheduler starts.  As it is stored as part of the task context it
will automatically be set to 0 when the first task is started. */
static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;

static timer_t xSystickTimerId;

/* Signal mask used by the prvSigResumeHandler */
static sigset_t xSuspendMask;

/* Public Functions ----------------------------------------------------------*/

/*
 * Stop all tasks and disable 'interrupts' (stop systick handling)
 */
void vPortPause ( void ) {
    /* Block until the scheduler has been started */
    pthread_mutex_lock(&xSchedulerStartedMutex);
    while (xSchedulerStarted == false) {
        pthread_cond_wait(&xSchedulerStartedCond, &xSchedulerStartedMutex);
    }
    pthread_mutex_unlock(&xSchedulerStartedMutex);

    /* No pause during critical section */
    while (sem_wait(&xCriticalSem));

    /* No Pause while context switch ongoing */
    while (sem_wait(&xSchedulerSem));

    xPaused = true;

    /* End running task */
    if (pxTasks[xTaskToResume].xUsed) {
        prvSuspendTaskBlocking(xTaskToResume);
    }

    /* All tasks are stopped by now */
    sem_post(&xSchedulerSem);
    sem_post(&xCriticalSem);
}
/*-----------------------------------------------------------*/

/*
 * Resume task execution stopped by vPortPause()
 */
void vPortResume ( void ) {
    if (xPaused) {
        xPaused = false;
        prvResumeTaskBlocking(xTaskToResume);
    }
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    if (uxCriticalNesting == 0)  {
        while (sem_wait(&xCriticalSem));
    }

    uxCriticalNesting++;
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    if (uxCriticalNesting == 1) {
        sem_post(&xCriticalSem);
    }

    if (uxCriticalNesting) { uxCriticalNesting--; }

    if( uxCriticalNesting == 0 && !xPaused) {

        if (xTimerTickPending) {
            pthread_kill(xMainThreadId, portSIGTIMER);
            xTimerTickPending = 0;
        }

        if (xYieldPending) {
            xYieldPending = false;
            vPortYield();
        }
    }
}
/*-----------------------------------------------------------*/

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack(
        StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) {

    /* Initialize task credentials */
    if (!xInitialized) {
        prvInit();
    }

    /* Find next free task index */
    size_t idx = configPORT_MAX_TASKS;
    for (size_t i = 0; i < configPORT_MAX_TASKS; i++) {
        if (pxTasks[i].xUsed == false) {
            idx = i;
            break;
        }
    }

    if (idx >= configPORT_MAX_TASKS) {
        ERREXIT("All threads occupied. Increase configPORT_MAX_TASKS");
    }

    /* Initialize task credentials */
    pxTasks[idx].xUsed = true;
    pxTasks[idx].xSuspended = true;
    pxTasks[idx].xId = idx;
    pxTasks[idx].pxHandle = NULL;
    pxTasks[idx].pxCode = pxCode;
    pxTasks[idx].pvParameters = pvParameters;
    xLastCreatedTaskId = idx;

    /* Temporarily block all signals (SIGMASK is inherited to threads) */
    sigset_t block, restore;
    sigfillset(&block);

    if (pthread_sigmask(SIG_BLOCK, &block, &restore) != 0) {
        ERREXIT("pthread_sigmask block all");
    }

    /* Create Thread */
    pthread_create((pthread_t *)&pxTasks[idx].xThreadId, NULL, prvTask,
            (void*)&pxTasks[idx]);

    /* Restore previous signal mask */
    if (pthread_sigmask(SIG_SETMASK, &restore, NULL) != 0) {
        ERREXIT("pthread_sigmask restore");
    }

    /*  Wait for created task to suspend */
    while (sem_wait(&xSuspendSem));

    return ( StackType_t * ) pxTopOfStack;
}
/*-----------------------------------------------------------*/

/*
 * Stores the RTOS task handle of the latest created task
 */
void vPortSetupTCB(void * pvTaskHandle) {
    TaskHandle_t handle = (TaskHandle_t) pvTaskHandle;

    if (xLastCreatedTaskId < configPORT_MAX_TASKS) {
        pxTasks[xLastCreatedTaskId].pxHandle = handle;
        xLastCreatedTaskId = configPORT_MAX_TASKS;
    } else {
        ERREXIT("Received task handle while id was invalid");
    }
}
/*-----------------------------------------------------------*/

/*
 * Task delete callback. End task, cleanup task credentials
 */
void vPortCleanUpTCB(void * pvTaskHandle) {
    int id = prvGetIdFromHandle((TaskHandle_t)pvTaskHandle);

    /* Check if the task handle was valid */
    if (id >= configPORT_MAX_TASKS) {
        ERREXIT("Cleanup: Received invalid task handle");
    }

    /* ------------------------------- */
    vPortEnterCritical();
    /* ------------------------------- */

    /*
     * If vTaskEndScheduler is called outside of RTOS tasks the idle task ends
     * itself.
     */
    if (pxTasks[id].xThreadId == pthread_self()) {
        if (id == xIdleTaskId) {
            pthread_exit(NULL);
        } else {
            ERREXIT("Cleanup: Tried to cancel active task");
        }
    }

    /* End thread running the task to delete */
    pthread_cancel(pxTasks[id].xThreadId);

    /*
     * Wait for thread to terminate, except the Idle thread which is joined at
     * the main thread
     */
    if (id != xIdleTaskId) {
        if (pthread_join(pxTasks[id].xThreadId, NULL) != 0) {
            ERREXIT("Cleanup: Unable to join");
        }
    }

    pxTasks[id].xUsed = false;

    /* ------------------------------- */
    vPortExitCritical();
    /* ------------------------------- */
}
/*-----------------------------------------------------------*/

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
    xMainThreadId = pthread_self();

    /* Get idle task id
     *
     * The idle task is the first task created by vTaskStartScheduler
     */
    int task_id_max = -1;
    for (int task = 1; task < configPORT_MAX_TASKS; task++) {
        if (!pxTasks[task].xUsed) {
            task_id_max = task -1;
            break;
        }
    }

    if (task_id_max < 0) {
        ERREXIT("Unable to find max task id");
    }

    #if ( configUSE_TIMERS == 1 )
        task_id_max--;
    #endif

    xIdleTaskId = task_id_max;

    /* Start scheduler, systick and enable interrupts */
    prvStartSchedulerThread();
    prvStartSystickTimer();
    uxCriticalNesting = 0;

    /* Resume first task */
    xTaskToResume = prvGetIdFromHandle(xTaskGetCurrentTaskHandle());

    /* Check if thread exists and is enabled */
    if ((xTaskToResume >= configPORT_MAX_TASKS) ||
        (pxTasks[xTaskToResume].xUsed == false)) {
        ERREXIT("Tried to resume invalid thread");
    }

    prvResumeTaskBlocking(xTaskToResume);

    /* Signal scheduler started */
    pthread_mutex_lock(&xSchedulerStartedMutex);
    xSchedulerStarted = true;
    pthread_mutex_unlock(&xSchedulerStartedMutex);
    pthread_cond_signal(&xSchedulerStartedCond);

    /* Handle Systicks */
    while (!xEndScheduler) {

        /* Process system tick */
        if (xSystick && !xPaused) {

            vPortPause();

            /* Increment tick, check if context switch is required */
            xSystick = 0;
            if (xTaskIncrementTick() == pdTRUE) {
                xPaused = false;
                vPortYield();
            } else {
                vPortResume();
            }
        }

        pause();

    } /* Main thread loop */

    prvSchedulerEndCleanup();

    return pdTRUE;
}
/*-----------------------------------------------------------*/


/*
 *  End scheduler
 */
void vPortEndScheduler( void )
{
    #if  ( INCLUDE_vTaskDelete == 1 )
    /* Avoid task switch by timer interrupt */
    vPortEnterCritical();

    /* Set Scheduler ended */
    pthread_mutex_lock(&xSchedulerStartedMutex);
    xSchedulerStarted = false;
    pthread_mutex_unlock(&xSchedulerStartedMutex);

    /* End scheduler, exit main thread loop */
    xEndScheduler = true;

    /* Delete every task except idle task which may be required for cleanup */
    for (int task = 0; task < configPORT_MAX_TASKS; task++) {
        if (pxTasks[task].xUsed && task != xIdleTaskId) {
            vTaskDelete(pxTasks[task].pxHandle);
        }
    }

    /* End Scheduler Task */
    prvResumeSchedulerBlocking();

    /* If called within RTOS Task, exit this thread */
    pthread_t current = pthread_self();
    for (int task = 0; task < configPORT_MAX_TASKS; task++) {
        if (pxTasks[task].xThreadId == current) {
            pthread_exit(NULL);
        }
    }

    #else
    ERREXIT("End Scheduler requires vTaskDelete");
    #endif
}
/*-----------------------------------------------------------*/

/*
 *  Task switch
 */
void vPortYield( void ) {
    /* Post is done at scheduler thread */
    while (sem_wait(&xSchedulerSem));

    prvResumeSchedulerBlocking();

    /* Suspend this task */
    if (pthread_self() != xMainThreadId) {
        pause();
    }

    return;
}
/*-----------------------------------------------------------*/

/*
 *  Delayed context switch
 */
void vPortYieldWithinAPI( void )  {
    if (uxCriticalNesting || xPaused) {
        xYieldPending = true;
    } else {
        vPortYield();
    }
}
/*-----------------------------------------------------------*/


/* Private Functions ---------------------------------------------------------*/

/*
 * Cleanup after scheduler has ended
 *
 * Run at main thread after vTaskEndScheduler has been called
 */
static void prvSchedulerEndCleanup( void ) {
    struct timespec xDelayTs = { .tv_sec = 0, .tv_nsec = 100000 };

    /* Resume the idle task */
    prvResumeTaskBlocking(xIdleTaskId);

    /* Wait for all tasks to be deleted and removed (except idle) */
    bool tasks_deleted = false;
    while (!tasks_deleted) {
        nanosleep(&xDelayTs, NULL);

        int count = 0;
        for (int task = 0; task < configPORT_MAX_TASKS; task++) {
            if (pxTasks[task].xUsed) { count++; };
        }

        if (count <= 1) {
            tasks_deleted = true;
        }
    }

    /* Finally delete the idle task */
    vTaskDelete(pxTasks[xIdleTaskId].pxHandle);

    /* Wait for the idle task to exit */
    if (pthread_join(pxTasks[xIdleTaskId].xThreadId, NULL) != 0) {
        ERREXIT("Cleanup: Unable to join");
    }

    /* End scheduler thread */
    pthread_cancel(xSchedulerThreadId);
    if (pthread_join(xSchedulerThreadId, NULL) != 0) {
        ERREXIT("Cleanup: Unable to join");
    }

    /* Stop the systick timer */
    prvStopSystickTimer();

    sem_destroy(&xSchedulerSem);
    sem_destroy(&xResumeSem);
    sem_destroy(&xSuspendSem);
    sem_destroy(&xCriticalSem);

    xInitialized = false;

    /* Reinitialize memory management */
    vPortInitialiseBlocks();
}
/*-----------------------------------------------------------*/


/*
 * Initialize global variables, semaphores  and register signal handlers
 */
static void prvInit(void) {

    /* Initialize global variables */
    /* --------------------------- */
    memset((void *)&pxTasks, 0, sizeof(pxTasks));
    xEndScheduler = false;
    xLastCreatedTaskId = configPORT_MAX_TASKS;
    xTaskToResume = configPORT_MAX_TASKS;
    xTaskToSuspend = configPORT_MAX_TASKS;

    xMainThreadId = 0;
    xSchedulerThreadId = 0;

    xSystick = 0;
    xTimerTickPending = 0;
    uxCriticalNesting = 0xaaaaaaaa;

    pthread_mutex_lock(&xSchedulerStartedMutex);
    xSchedulerStarted = false;
    pthread_mutex_unlock(&xSchedulerStartedMutex);

    /* Initialize semaphores */
    /* --------------------- */
    if (sem_init(&xSchedulerSem, 0, 1) != 0) {
        ERREXIT("sem init");
    }

    if (sem_init(&xResumeSem, 0, 0) != 0) {
        ERREXIT("sem init");
    }

    if (sem_init(&xSuspendSem, 0, 0) != 0) {
        ERREXIT("sem init");
    }

    if (sem_init(&xCriticalSem, 0, 1) != 0) {
        ERREXIT("sem init");
    }

    /* Setup suspend mask */
    /* ------------------ */
    sigfillset(&xSuspendMask);
    sigdelset(&xSuspendMask, portSIGRESUME);

    /* Register Signal Handlers */
    /* ------------------------ */
    struct sigaction sa;

    /* Register (empty) Handler for portSIGRESUME */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART | SA_SIGINFO;
    sa.sa_sigaction = prvSigResumeHandler;

    if (sigaction(portSIGRESUME, &sa, NULL) == -1) {
        ERREXIT("portSIGRESUME handler");
    }

    /* Register Handler for portSIGSUSPEND */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART | SA_SIGINFO;
    sa.sa_sigaction = prvSigSuspendHandler;

    if (sigaction(portSIGSUSPEND, &sa, NULL) == -1) {
        ERREXIT("portSIGSUSPEND handler");
    }

    /* Establish handler for timer signal */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART | SA_SIGINFO;
    sa.sa_sigaction = prvSigtimerHandler;

    if (sigaction(portSIGTIMER, &sa, NULL) == -1) {
        ERREXIT("sigaction");
    }

    xInitialized = true;
}
/*-----------------------------------------------------------*/

/*
 * portSIGRESUME Handler
 */
static void prvSigResumeHandler(int sig, siginfo_t *si, void *uc) {
    /* nothing to do here */
    (void) sig;
    (void) si;
    (void) uc;
}
/*-----------------------------------------------------------*/

/*
 * portSIGSUSPEND Handler
 */
static void prvSigSuspendHandler(int sig, siginfo_t *si, void *uc) {

    pthread_t thread_id = pthread_self();
    int id = prvGetIdFromThreadId(thread_id);

    if (id >= configPORT_MAX_TASKS) {
        ERREXIT("Suspend handler invalid id");
    }

    pxTasks[id].xSuspended = true;
    sem_post(&xSuspendSem);

    /* Suspend the thread until portSIGRESUME is received */
    sigsuspend(&xSuspendMask);

    pxTasks[id].xSuspended = false;
    sem_post(&xResumeSem);

    /* Compiler warnings */
    (void) sig;
    (void) si;
    (void) uc;
}
/*-----------------------------------------------------------*/

/*
 * portSIGTIMER handler
 */
static void prvSigtimerHandler(int sig, siginfo_t *si, void *uc) {
    /* Pend tick if timer is disabled */
    if (uxCriticalNesting || xPaused) {
        xTimerTickPending = 1;
    } else {
        xSystick = 1;
    }

    /* Compiler warnings */
    (void) sig;
    (void) si;
    (void) uc;
}
/*-----------------------------------------------------------*/

/*
 * Starts the Scheduler
 */
static void prvStartSchedulerThread(void) {
    pthread_create(&xSchedulerThreadId, NULL, prvSchedulerThread, NULL);
}
/*-----------------------------------------------------------*/


/*
 * Scheduler suspends/resumes RTOS tasks
 */
static void * prvSchedulerThread(void *arg) {
    /* Set Signal Mask */
    sigset_t maskset;
    sigfillset(&maskset);

    if (pthread_sigmask(SIG_SETMASK, &maskset, NULL) != 0) {
        ERREXIT("pthread_sigmask taskset");
    }

    while (1) {

        /* Wait for a Yield */
        pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);

        pthread_mutex_lock(&xSchedulerMutex);
        while (xResumeScheduler != true) {
            pthread_cond_wait(&xSchedulerCond, &xSchedulerMutex);
        }
        xResumeScheduler = false;
        pthread_mutex_unlock(&xSchedulerMutex);

        pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);

        /* Check if scheduler scheduler should exit */
        if (xEndScheduler) { break; }

        /* Currently running task */
        xTaskToSuspend = prvGetIdFromHandle(xTaskGetCurrentTaskHandle());

        /* Check if thread exists and is enabled */
        if (xTaskToSuspend >= configPORT_MAX_TASKS ||
            pxTasks[xTaskToSuspend].xUsed == false) {
            ERREXIT("Tried to suspend invalid thread");
        }

        vTaskSwitchContext();

        /* Task to run after actual task switch */
        xTaskToResume = prvGetIdFromHandle(xTaskGetCurrentTaskHandle());

        /* Check if thread exists and is enabled */
        if (xTaskToResume >= configPORT_MAX_TASKS ||
            pxTasks[xTaskToResume].xUsed == false) {
            ERREXIT("Tried to resume invalid thread");
        }

        /* Perform context switch */
        if (!pxTasks[xTaskToSuspend].xSuspended) {
            /* Suspend thread */
            prvSuspendTaskBlocking(xTaskToSuspend);
        }

        /* Resume thread */
        prvResumeTaskBlocking(xTaskToResume);

        /* Unlock scheduler */
        sem_post(&xSchedulerSem);
    }

    pthread_exit(NULL);

    /* Compiler warning */
    (void) arg;
}
/*-----------------------------------------------------------*/

/*
 * Thread function running RTOS Tasks
 */
static void * prvTask(void * arg) {
    portTask_t * id = (portTask_t*)arg;

    /* Set Signal Mask */
    sigset_t taskset;
    sigfillset(&taskset);
    sigdelset(&taskset, portSIGSUSPEND);
    sigdelset(&taskset, SIGINT);

    if (pthread_sigmask(SIG_SETMASK, &taskset, NULL) != 0) {
        ERREXIT("pthread_sigmask taskset");
    }

    /* Suspend thread */
    pthread_kill(id->xThreadId, portSIGSUSPEND);

    /* First resume, check if initialization was done */
    if (id->pxHandle == NULL) {
        ERREXIT("RTOS Task misses task handle");
    }

    /* RTOS Task function (shouldn't return, but might) */
    /* ------------------------------------------------ */
    id->pxCode(id->pvParameters);


    /* Thread termination */
    /* ------------------ */
    LOG("[WARN] RTOS task %d returned", id->xId);

    #if (INCLUDE_vTaskDelete == 1)
        /* Task will be removed by the idle task */
        vTaskDelete(NULL);
        pthread_kill(id->xThreadId, portSIGSUSPEND);
    #else
        ERREXIT("RTOS Task returned");
    #endif

    pthread_exit(NULL);
}
/*-----------------------------------------------------------*/

/*
 * Initialize and start systick timer
 */
static bool prvStartSystickTimer(void) {
    struct sigevent sev;
    struct itimerspec its;
    long long freq_nanosecs;

    /* Unblock portSIGTIMER */
    sigset_t timer_set;
    sigemptyset(&timer_set);
    sigaddset(&timer_set, portSIGTIMER);
    sigaddset(&timer_set, SIGINT);

    if (pthread_sigmask(SIG_UNBLOCK, &timer_set, NULL) != 0) {
        ERREXIT("pthread_sigmask timer");
    }

    /* Create the timer */
    memset(&sev, 0, sizeof(struct sigevent));
    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = portSIGTIMER;
    sev.sigev_value.sival_ptr = &xSystickTimerId;
    if (timer_create(CLOCK_MONOTONIC, &sev, &xSystickTimerId) == -1) {
        ERREXIT("timer_create");
    }

    /* Start the timer */
    /* TODO make frequency configurable */
    freq_nanosecs = 1000000;
    memset(&its, 0, sizeof(struct itimerspec));

    its.it_interval.tv_sec = freq_nanosecs / 1000000000;
    its.it_interval.tv_nsec = freq_nanosecs % 1000000000;
    its.it_value.tv_sec = its.it_interval.tv_sec;
    its.it_value.tv_nsec = its.it_interval.tv_nsec;

    if (timer_settime(xSystickTimerId, 0, &its, NULL) == -1) {
        ERREXIT("timer_settime");
    }

    return true;
}
/*-----------------------------------------------------------*/

/*
 * Stop systick timer
 */
static void prvStopSystickTimer(void) {
    if (timer_delete(xSystickTimerId) != 0) {
        ERREXIT("Unable to stop timer");
    }
}

/* Helper Functions */
/* -------------------------------------------------------------------------- */

/*
 * Get internal task id from RTOS task handle
 */
static int prvGetIdFromHandle(TaskHandle_t handle) {
    int idx = configPORT_MAX_TASKS;

    for (int i = 0; i < configPORT_MAX_TASKS; i++) {
        if (pxTasks[i].pxHandle == handle) {
            idx = i;
            break;
        }
    }

    return idx;
}
/*-----------------------------------------------------------*/

/*
 *  Get internal task id from pthread id
 */
static int prvGetIdFromThreadId(pthread_t id) {
    int idx = configPORT_MAX_TASKS;

    for (int i = 0; i < configPORT_MAX_TASKS; i++) {
        if (pxTasks[i].xThreadId == id) {
            idx = i;
            break;
        }
    }

    return idx;
}
/*-----------------------------------------------------------*/


/*
 * Get nanosecond timestamp (process clock)
 */
__attribute__((unused)) static unsigned long prvGetNsTs(void) {
    struct timespec ts;
    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts);

    return ts.tv_nsec;
}
/*-----------------------------------------------------------*/


/* Send portSIGRESUME to task and block until it is resumed */
static void prvResumeTaskBlocking(int task_id) {

    pthread_kill(pxTasks[task_id].xThreadId, portSIGRESUME);
    while ( sem_wait(&xResumeSem) );

    /* There can only be one task */
    int semval;
    sem_getvalue(&xResumeSem, &semval);
    if (semval) {
        ERREXIT("Resumed multiple tasks");
    }
}
/*-----------------------------------------------------------*/

/* Send portSIGSUSPEND to task and block until it is suspended */
static void prvSuspendTaskBlocking(int task_id) {
    pthread_kill(pxTasks[task_id].xThreadId, portSIGSUSPEND);
    while (sem_wait(&xSuspendSem));
}
/*-----------------------------------------------------------*/

/*
 * Resume the scheduler thread
 */
static void prvResumeSchedulerBlocking(void) {
    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);

    /* Resume Scheduler Task */
    pthread_mutex_lock(&xSchedulerMutex);
    xResumeScheduler = true;
    pthread_mutex_unlock(&xSchedulerMutex);
    pthread_cond_signal(&xSchedulerCond);

    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
}
/*-----------------------------------------------------------*/


/* License notice ----------------------------------------------------------- */

/*
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
