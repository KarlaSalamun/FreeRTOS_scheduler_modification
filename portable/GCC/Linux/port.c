/*
 * FreeRTOS Port implementation for Linux using POSIX Threads
 *
 * - Each RTOS tasks runs in a own thread
 * - Threads are suspended / resumed by async signals
 * - Those signal are generated by the scheduler thread
 * - vPortYield triggers the scheduler thread
 * - The systick is generated by a POSIX timer
 * - and is handled synchronized within the main thread
 * - While systick is handled all threads running RTOS tasks are suspended
 *
 *
 * Copyright (C) 2019 Andreas Innerlohninger <innerand@nxa.at>
 *
 * This code is subject to the terms and conditions defined at the MIT Licence
 * which are specified at the end of this file and/or a separate license file.
 */


/* Includes ------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>

#include "FreeRTOS.h"
#include "task.h"


/* Private Defintions --------------------------------------------------------*/

#define ERREXIT(s)  printf("Error: %s (%s[%d], %s)", (s), __FUNCTION__, __LINE__, __FILE__); exit(1)
// #define LOG(msg,...) printf("[%ld]", prvGetNsTs()); printf(msg, ##__VA_ARGS__); printf("\n");
#define LOG(msg,...)

/* Signals */
#define SIGTIMER    (SIGRTMIN + 1)
#define SIGSUSPEND  SIGUSR1
#define SIGRESUME   SIGUSR2

/** Internal task credentials */
typedef struct {
    bool xUsed;               /* Task created */
    sig_atomic_t xSuspended;  /* Task suspended */
    int xId;                  /* Internal task ID */
    pthread_t xThreadId;      /* ID of the POSIX thread running the task */
    TaskHandle_t pxHandle;    /* RTOS task handle */
    TaskFunction_t pxCode;    /* RTOS task function */
    void * pvParameters;      /* RTOS function parameters */
} portTask_t;


/* Private Function declarations ---------------------------------------------*/

static void prvInit(void);
static void prvStartSchedulerThread(void);
static bool prvStartSystickTimer(void);
static void * prvSchedulerThread(void *arg);
static void * prvTask(void * arg);
static unsigned long prvGetNsTs(void);
static int prvGetTaskIdFromHandle(TaskHandle_t handle);
static int prvGetIdFromThreadId(pthread_t id);

static void prvSigResumeHandler(int sig, siginfo_t *si, void *uc);
static void prvSigSuspendHandler(int sig, siginfo_t *si, void *uc);
static void prvSigtimerHandler(int sig, siginfo_t *si, void *uc);


/* Private Variables ---------------------------------------------------------*/

static volatile portTask_t pxTasks[configPORT_MAX_TASKS];
static bool xEndScheduler = false;
static int xLastCreatedTaskId = configPORT_MAX_TASKS;
static bool xInitialized = false;

/* Context switch IDs */
static volatile int xThreadToResume = configPORT_MAX_TASKS;
static volatile int xThreadToSuspend = configPORT_MAX_TASKS;

/* System Threads */
static pthread_t xMainThreadId;
static pthread_t xSchedulerThreadId;
static pthread_mutex_t xSchedulerMutex;

/* Flags */
static volatile sig_atomic_t xSystick = 0;
static volatile sig_atomic_t xInterruptsDisabled = 0;
static volatile sig_atomic_t xTimerTickPending = 0;
static volatile bool xSchedulerResumed;

/* A variable is used to keep track of the critical section nesting.  This
variable has to be stored as part of the task context and must be xInitialized
to a non zero value to ensure interrupts don't inadvertently become unmasked
before the scheduler starts.  As it is stored as part of the task context it
will automatically be set to 0 when the first task is started. */
static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;

/* Delay of the resend of a signal if it wasn't confirmed */
const struct timespec xSignalResendDelay = { .tv_sec = 0, .tv_nsec = 5000 };


/* Public Functions ----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    xInterruptsDisabled = 1;
	uxCriticalNesting++;
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	if (uxCriticalNesting) { uxCriticalNesting--;}

	if( uxCriticalNesting == 0 ) {
		xInterruptsDisabled = 0;
        if (xTimerTickPending) {
            pthread_kill(xMainThreadId, SIGTIMER);
            xTimerTickPending = 0;
        }
	}
}
/*-----------------------------------------------------------*/

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack(
        StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) {

    /* Initialize task credentials */
    if (!xInitialized) {
        prvInit();
    }

    /* Find next free task index */
    size_t idx = configPORT_MAX_TASKS;
    for (size_t i = 0; i < configPORT_MAX_TASKS; i++) {
        if (pxTasks[i].xUsed == false) {
            idx = i;
            break;
        }
    }

    if (idx >= configPORT_MAX_TASKS) {
        ERREXIT("All threads occupied. Increase configPORT_MAX_TASKS");
    }

    LOG("[INFO] Creating Task with ID %d", idx);

    /* Initialize task credentials */
    pxTasks[idx].xUsed = true;
    pxTasks[idx].xSuspended = true;
    pxTasks[idx].xId = idx;
    pxTasks[idx].pxHandle = NULL;
    pxTasks[idx].pxCode = pxCode;
    pxTasks[idx].pvParameters = pvParameters;
    xLastCreatedTaskId = idx;

    /* Temporarily block all signals (SIGMASK is inherited to threads) */
    sigset_t block, restore;
    sigfillset(&block);
    sigdelset(&block, SIGINT);

    if (sigprocmask(SIG_BLOCK, &block, &restore) != 0) {
        ERREXIT("sigprocmask block all");
    }

    /* Create Thread */
    pthread_create((pthread_t *)&pxTasks[idx].xThreadId, NULL, prvTask,
            (void*)&pxTasks[idx]);

    /* Restore previous signal mask */
    if (sigprocmask(SIG_BLOCK, &restore, NULL) != 0) {
        ERREXIT("sigprocmask restore");
    }

	return ( StackType_t * ) pxTopOfStack;
}
/*-----------------------------------------------------------*/

/*
 * Stores the RTOS task handle of the latest created task
 */
void vPortSetupTCB(void * pvTaskHandle) {
    TaskHandle_t handle = (TaskHandle_t) pvTaskHandle;

    if (xLastCreatedTaskId < configPORT_MAX_TASKS) {
        pxTasks[xLastCreatedTaskId].pxHandle = handle;
        LOG("[INFO] Received handle of Task ID %d", xLastCreatedTaskId);
        xLastCreatedTaskId = configPORT_MAX_TASKS;
    } else {
        LOG("[ERR] Received task handle while id was invalid");
    }
}
/*-----------------------------------------------------------*/

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
    /* Main thread/Scheduler */
    LOG("[INFO] Starting scheduler.. ");

    xMainThreadId = pthread_self();

    if (pthread_mutex_init(&xSchedulerMutex, NULL) != 0) {
        ERREXIT("mutex init");
    }

    prvStartSchedulerThread();
    prvStartSystickTimer();
    uxCriticalNesting = 0;

    /* Resume first task */
    xThreadToResume = prvGetTaskIdFromHandle(xTaskGetCurrentTaskHandle());

    /* Check if thread exists and is enabled */
    if ((xThreadToResume >= configPORT_MAX_TASKS) ||
        (pxTasks[xThreadToResume].xUsed == false)) {
        ERREXIT("Tried to resume invalid thread");
    }

    LOG("[INFO] Resuming first RTOS Task (%d)", xThreadToResume);
    if (pthread_kill(pxTasks[xThreadToResume].xThreadId, SIGRESUME) != 0) {
        LOG("[ERR] Couldn't send signal SIGRESUME");
    };

    /* This thread does nothing but handle the Systick */
    while(!xEndScheduler) {
        pause();

        /* Process system tick */
        if (xSystick) {
            xSystick = 0;

            /* Make sure there is no ongoing task switch */
            pthread_mutex_lock(&xSchedulerMutex);

            /* Suspend active thread */
            do {
                pthread_kill(pxTasks[xThreadToResume].xThreadId, SIGSUSPEND);
                nanosleep(&xSignalResendDelay, NULL);
            } while (!pxTasks[xThreadToResume].xSuspended);

            /* All RTOS task should be suspended by now */
            pthread_mutex_unlock(&xSchedulerMutex);

            /* Increment tick, check if context switch is required */
            if (xTaskIncrementTick() == pdTRUE) {
                vPortYield();
            }

            pthread_mutex_lock(&xSchedulerMutex);
            while (pxTasks[xThreadToResume].xSuspended) {
                pthread_kill(pxTasks[xThreadToResume].xThreadId, SIGRESUME);
                nanosleep(&xSignalResendDelay, NULL);
            }

            // tasks_sanity_check();
            pthread_mutex_unlock(&xSchedulerMutex);
        }
    }

	return pdTRUE;
}
/*-----------------------------------------------------------*/

/*
 *  End scheduler
 */
void vPortEndScheduler( void )
{
    xEndScheduler = true;
    /* TODO */
    ERREXIT("unimplemented");
}
/*-----------------------------------------------------------*/

/*
 *  Task switch
 */
void vPortYield( void ) {
    /* Unlock is done at scheduler thread */
    pthread_mutex_lock(&xSchedulerMutex);

    /* Currently running task */
    xThreadToSuspend = prvGetTaskIdFromHandle(xTaskGetCurrentTaskHandle());

    /* Check if thread exists and is enabled */
    if (xThreadToSuspend >= configPORT_MAX_TASKS ||
        pxTasks[xThreadToSuspend].xUsed == false) {
        ERREXIT("Tried to suspend invalid thread");
    }

    vTaskSwitchContext();

    /* Task to run after actual task switch */
    xThreadToResume = prvGetTaskIdFromHandle(xTaskGetCurrentTaskHandle());

    /* Check if thread exists and is enabled */
    if (xThreadToResume >= configPORT_MAX_TASKS ||
        pxTasks[xThreadToResume].xUsed == false) {
        ERREXIT("Tried to resume invalid thread");
    }

    /* Resume scheduler thread */
    xSchedulerResumed = false;
    do {
        pthread_kill(xSchedulerThreadId, SIGRESUME);
        struct timespec ts;
        nanosleep(&xSignalResendDelay, NULL);
    } while (!xSchedulerResumed);

    /* Stop current thread */
    if (pthread_self() != xMainThreadId &&
        xThreadToResume != xThreadToSuspend) {
        pause();
    }
}
/*-----------------------------------------------------------*/


/* Private Functions ---------------------------------------------------------*/

/*
 * Initialize global functions and register signal handlers
 */
static void prvInit(void) {

    /* Initialize global variables */
    /* --------------------------- */

    memset((void *)&pxTasks, 0, sizeof(pxTasks));
    xEndScheduler = false;
    xLastCreatedTaskId = configPORT_MAX_TASKS;

    xThreadToResume = configPORT_MAX_TASKS;
    xThreadToSuspend = configPORT_MAX_TASKS;

    pthread_t xMainThreadId = 0;
    pthread_t xSchedulerThreadId = 0;

    xSystick = 0;
    xInterruptsDisabled = 0;
    xTimerTickPending = 0;
    xSchedulerResumed = false;
    uxCriticalNesting = 0xaaaaaaaa;

    /* Register Signal Handlers */
    /* ------------------------ */
    struct sigaction sa;

    /* Register (empty) Handler for SIGRESUME */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART | SA_SIGINFO;
    sa.sa_sigaction = prvSigResumeHandler;

    if (sigaction(SIGRESUME, &sa, NULL) == -1) {
        ERREXIT("SIGRESUME handler");
    }

    /* Register Handler for SIGSUSPEND */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART | SA_SIGINFO;
    sa.sa_sigaction = prvSigSuspendHandler;

    if (sigaction(SIGSUSPEND, &sa, NULL) == -1) {
        ERREXIT("SIGSUSPEND handler");
    }

    /* Establish handler for timer signal */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART | SA_SIGINFO;
    sa.sa_sigaction = prvSigtimerHandler;

    if (sigaction(SIGTIMER, &sa, NULL) == -1) {
        ERREXIT("sigaction");
    }

    xInitialized = true;
}
/*-----------------------------------------------------------*/

/*
 * SIGRESUME Handler
 */
static void prvSigResumeHandler(int sig, siginfo_t *si, void *uc) {
    /* nothing to do here */
    (void) sig;
    (void) si;
    (void) uc;
}
/*-----------------------------------------------------------*/

/*
 * SIGSUSPEND Handler
 */
static void prvSigSuspendHandler(int sig, siginfo_t *si, void *uc) {
    sigset_t suspend_mask;
    sigfillset(&suspend_mask);
    sigdelset(&suspend_mask, SIGRESUME);

    pthread_t thread_id = pthread_self();
    int id = prvGetIdFromThreadId(thread_id);

    if (id >= configPORT_MAX_TASKS) {
        LOG("[FATAL] Suspend handler invalid id");
        return;
    }

    pxTasks[id].xSuspended = true;

    /* Suspend the thread until SIGRESUME is received */
    sigsuspend(&suspend_mask);

    pxTasks[id].xSuspended = false;
}
/*-----------------------------------------------------------*/

/*
 * SIGTIMER handler
 */
static void prvSigtimerHandler(int sig, siginfo_t *si, void *uc) {
    /* Pend tick if timer is disabled */
    if (xInterruptsDisabled > 0) {
        xTimerTickPending = 1;
    } else {
        xSystick = 1;
    }
}
/*-----------------------------------------------------------*/

/*
 * Starts the Scheduler
 */
static void prvStartSchedulerThread(void) {
    pthread_create(&xSchedulerThreadId, NULL, prvSchedulerThread, NULL);
}
/*-----------------------------------------------------------*/


/*
 * Scheduler pausing/resuming RTOS tasks
 */
static void * prvSchedulerThread(void *arg) {
    /* Set Signal Mask */
    sigset_t schedulerset;
    sigfillset(&schedulerset);
    sigdelset(&schedulerset, SIGRESUME);
    sigdelset(&schedulerset, SIGINT);

    if (sigprocmask(SIG_SETMASK, &schedulerset, NULL) != 0) {
        ERREXIT("sigprocmask taskset");
    }

    LOG("[INFO] Scheduler thread started");
    while(!xEndScheduler) {
        /* Wait for next context switch */
        sigsuspend(&schedulerset);
        xSchedulerResumed = true;

        /* Suspend thread */
        if ((xThreadToSuspend < configPORT_MAX_TASKS) &&
            (pxTasks[xThreadToSuspend].xUsed)) {

            if (!pxTasks[xThreadToSuspend].xSuspended) {
                do {
                    pthread_kill(pxTasks[xThreadToSuspend].xThreadId,
                                 SIGSUSPEND);
                    nanosleep(&xSignalResendDelay, NULL);
                } while(!pxTasks[xThreadToSuspend].xSuspended);
            }
        }

        /* Resume thread */
        if ((xThreadToResume < configPORT_MAX_TASKS) &&
            pxTasks[xThreadToResume].xUsed) {

            if (pxTasks[xThreadToResume].xSuspended != 0) {
                while(pxTasks[xThreadToResume].xSuspended) {
                    pthread_kill(pxTasks[xThreadToResume].xThreadId, SIGRESUME);
                    nanosleep(&xSignalResendDelay, NULL);
                };
            }
        }

        pthread_mutex_unlock(&xSchedulerMutex);
    }

    LOG("[INFO] Scheduler thread exited..");
}
/*-----------------------------------------------------------*/

/*
 * Thread function running RTOS Tasks
 */
static void * prvTask(void * arg) {
    portTask_t * id = (portTask_t*)arg;

    /* Set Signal Mask */
    sigset_t taskset;
    sigfillset(&taskset);
    sigdelset(&taskset, SIGSUSPEND);
    sigdelset(&taskset, SIGRESUME);
    sigdelset(&taskset, SIGINT);

    if (sigprocmask(SIG_SETMASK, &taskset, NULL) != 0) {
        ERREXIT("sigprocmask taskset");
    }

    /* Suspend thread */
    LOG("[INFO] RTOS task thread %d started", id->id);
    pthread_kill(id->xThreadId, SIGSUSPEND);

    /* First Resume - check if initialization was done */
    if (id->pxHandle == NULL) {
        ERREXIT("RTOS Task misses task handle");
    }

    /* RTOS Task function (shouldn't return, but might) */
    /* ------------------------------------------------ */
    LOG("[INFO] Starting RTOS task function of thread %d", id->id);
    id->pxCode(id->pvParameters);


    /* Thread termination */
    /* ------------------ */
    LOG("[INFO] Exited RTOS task thread %d", id->id);
    // TODO RTOS Cleanup

    pthread_exit(NULL);
}
/*-----------------------------------------------------------*/

/*
 * Initialize and start systick timer
 */
static bool prvStartSystickTimer(void) {
    timer_t timerid;
    struct sigevent sev;
    struct itimerspec its;
    long long freq_nanosecs;
    sigset_t mask;

    /* Unblock SIGTIMER */
    sigset_t timer_set;
    sigemptyset(&timer_set);
    sigaddset(&timer_set, SIGTIMER);
    sigaddset(&timer_set, SIGINT);

    if (sigprocmask(SIG_UNBLOCK, &timer_set, NULL) != 0) {
        ERREXIT("sigprocmask timer");
    }

    /* Create the timer */
    memset(&sev, 0, sizeof(struct sigevent));
    sev.sigev_notify = SIGEV_SIGNAL;
    sev.sigev_signo = SIGTIMER;
    sev.sigev_value.sival_ptr = &timerid;
    if (timer_create(CLOCK_MONOTONIC, &sev, &timerid) == -1) {
        ERREXIT("timer_create");
    }

    /* Start the timer */
    /* TODO make frequency configurable */
    freq_nanosecs = 100000;
    memset(&its, 0, sizeof(struct itimerspec));

    its.it_interval.tv_sec = freq_nanosecs / 1000000000;
    its.it_interval.tv_nsec = freq_nanosecs % 1000000000;
    its.it_value.tv_sec = its.it_interval.tv_sec;
    its.it_value.tv_nsec = its.it_interval.tv_nsec;

    if (timer_settime(timerid, 0, &its, NULL) == -1) {
        ERREXIT("timer_settime");
    }

    LOG("[INFO] Systick timer started");
    return true;
}
/*-----------------------------------------------------------*/



/* Helper Functions */
/* -------------------------------------------------------------------------- */

/*
 * Get internal task id from RTOS task handle
 */
static int prvGetTaskIdFromHandle(TaskHandle_t handle) {
    int idx = configPORT_MAX_TASKS;

    for (int i = 0; i < configPORT_MAX_TASKS; i++) {
        if (pxTasks[i].pxHandle == handle) {
            idx = i;
            break;
        }
    }

    if (idx >= configPORT_MAX_TASKS) {
        LOG("[ERR] Couldn't find requested Task handle");
    }

    return idx;
}
/*-----------------------------------------------------------*/

/*
 *  Get internal task id from pthread id
 */
static int prvGetIdFromThreadId(pthread_t id) {
    int idx = configPORT_MAX_TASKS;

    for (int i = 0; i < configPORT_MAX_TASKS; i++) {
        if (pxTasks[i].xThreadId == id) {
            idx = i;
            break;
        }
    }

    if (idx >= configPORT_MAX_TASKS) {
        LOG("[ERR] Couldn't find requested thread id");
    }

    return idx;
}
/*-----------------------------------------------------------*/


/*
 * Get nanosecond timestamp (process clock)
 */
static unsigned long prvGetNsTs(void) {
    struct timespec ts;
    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts);

    return ts.tv_nsec;
}
/*-----------------------------------------------------------*/



/* Licence notice ----------------------------------------------------------- */

/*
 * MIT Licence
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
